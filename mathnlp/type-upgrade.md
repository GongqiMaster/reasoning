## 数学命名实体识别

NER主要基于一种想法：中文实体类型和英文实体名是紧挨着的，即使不紧挨着，也有出现的规律。这部分可以回去看综述里面的实体组成部分。

NER主要由以下步骤组成：
1. 实体（变量）引入；
2. 类型补全；
3. 标准实体对检测（base ner）；
4. 基于一阶谓词逻辑的类型递进。

python版本源码位置：mathnerdevelop/utils/intro_util.py

下面分别介绍大概思路。

### 实体对类型

一个完整的NER单元由一个中文实体类型和英文实体名称组成，即

`<EntityType, EntityName>`

这样一个EntityPair需要有一个标识的类型EntityPairType，主要由以下几类：
1. `STD`: 标准实体对
2. `UPGRADE`: 被类型递进的实体对
3. `NOEN`: 被引入英文实体的实体对
4. `NOZH`: 被补全中文类型的实体对
5. `NOALL`: 既没有中文也没有英文的实体对，概念
6. `APPERAED`: 前面出现过的实体对，一般是仅有英文实体名称，在前面的短句或当前短句的前半部分出现过
7. `PARALLEL`: 并列成分实体对，指的是首个并列成员之后的从属并列成员的实体对类型，内部表现形式是`PARALLEL<首个并列成员>`

### STEP1: 实体引入

这一步检查分词后的结果，若中文实体类型后面没有**紧跟**一个英文实体名称（oe开头），在后面插入一个新的引入的实体。注意排除了一些如"x轴"的特殊情况，此时英文实体名称紧跟在中文实体类型前面。

新引入的英文实体（变量），以`rs`开头，从`0`开始计数，不加入到实体映射表当中。这里使用了短句内的局部引用计数和整个题目的全局引用计数方式，且不和`oe`开头的现有实体的引用计数重复。

```
例：若三角形oe0的斜边长为oe1（其实这里`长`会被同义词替换为`长度`）

分词结果：若 三角形 oe0 的 斜边 长 为 oe1

引入实体后：若三角形oe0的斜边rs0长rs1为oe1

引入实体后的分词结果：若 三角形 oe0 的 斜边 rs0 长 rs1 为 oe1
```

注1：实体引入部分由于跟分词有直接关联，实际上应该算作NER的前驱工作，该部分在`mathnerdevelop/utils/ltp_util.py`中的原始代码已废弃，目前被统一整合进了`mathnerdevelop/utils/intro_util.py`中。

注2：实体引入会简单检测数量词，并引入对应数量词的实体（最大支持10个并列成分）。这一步的目的是为了实现并列的一阶谓词逻辑结构的**挨个递进**，但会产生一些问题，后面会使用其他方法修复，这部分不在这里细说。

### STEP2: 类型补全

类型补全在实体引入之后，检查英文实体前面是否都紧跟一个中文类型（除去`x轴`等特殊情况）。若没有，则为当前英文实体补全一个中文类型。

若该英文实体名称在前文出现过而当前短句中不明确，使用前文的信息，跳过补全。

类型补全主要思路有两个：
1. 正则表达式switch-case，具体表现为`mathnerdevelop/utils/intro_util.py`开头独立的`complete`函数，整体识别一些比较显而易见的表达式类型。这部分称之为**表达式外部特征分析**；
2. 表达式拆分，具体表现为`mathnerdevelop/analyse_express/`文件夹中的所有库文件，依据的原则是更细致的正则表达式和前文实体特征分析。这部分的工作比较繁琐，涉及到实体的拆分、类型的覆盖等，且不完全属于NER，该部分的代码也不在`mathnerdevelop/utils/intro_util.py`中。暂且留个坑，以后回单读写一个板块。

### STEP3: 标准实体对检测

通过`STEP1`和`STEP2`，所有缺失英文实体的中文类型都被引入了一个新实体，所有缺失中文类型的英文实体都被补全了一个中文类型。

注：这里可以作为一个分割，若某个实体确实没有得到，很可能是前面的流程的问题。多半是分词或者词性的原因，检测和修复起来也很方便。

引入和补全，不是直接在原始的分词结果`list`上做修改，因为NER还没有结束，插入和删除元素会引发一些效率上的问题（C++版本中使用的数据结构是`std::vector`，可能引起空间重新配置）。具体则是一开始便配置好了一个`EntityChunk`对象数组，保存、修改实体的某些信息。

这里检测标准实体对，就是整合不同情况的`EntityChunk`，里面会有一个成员变量`pair_type`标识实体对的类型。然后会被用于下一步的类型递进。

### STEP4: 类型递进

类型递进也叫类型升级，受到复旦大学NER系统的启发，很多实体会用一阶谓词逻辑来表述`EntityName`和`EntityType`之间的联系。**注意这种联系不是实体和实体之间的关系**。

举几个简单的例子：

```
例1：三角形$ABC$是等腰直角三角形
```

那么英文实体名称`ABC`的中文类型是什么？`ABC`前面是`三角形`，那么`等腰直角三角形`这个信息该如何保留？

```
例2：$P$是椭圆$O$上的一动点
```

显然`P`的中文类型就是`动点`了，但依据是什么呢？可能`动点`和`P`之间相隔很远，在不使用`DeepLearning`的情况下，需要找到一个可以让他们互相关联起来的标准。

这个标准就是类型递进原则，依据的是
1. 带有引用计数的一阶谓词检测
2. 惰性递进原则与类型递进表

下面一个一个来分析。

#### PART1: 数学文本中的一阶谓词逻辑

一阶谓词逻辑表述即

```
A is B
```

翻译成中文就是

```
A 是/为/都是/都为... B
```

这种结构很好判断，只需要首先找到这些特定的谓语动词即可，它们的词性一定是动词`v`。

这种结构在数学文本中很常见的一种形式是`A`、`B`一个是中文，另一个仅是英文（如上面例2）；或者一个是中文，另一个中文英文都有（如上面例1）。

#### PART2: 带引用计数的一阶谓词检测

这里针对的是嵌套一阶谓词的复杂句式，以及并列的一阶谓词逻辑不规范表述。

```
例1：$P$是(count:1)圆心为(count:1)$O$的圆上的一动点

例2：$P$、$M$、$N$分别是(count:3)线段$AB$、$CD$、$EF$的中点
```

使用类型递进之前，首先检查可用的一阶谓词的引用计数是否大于0。若可用，产生一次类型递进，将对应一阶谓词的引用计数减1。

注：目前采用的引用计数初始都是1，对于例2的情况，因为并列结构检测的不规范性难以得知`count`的准确数值，目前使用`PART6`的方法完成例2。

#### PART3: 惰性递进原则与类型递进表

产生一次`类型递进`，须遵循以下原则：
1. 递进只能发生在`NOZH / STD / APPEARED / PARALLEL`实体对 -> `NOEN`实体对之间，但并不规定它们的相对位置；
2. 产生递进的两个实体对之间需要存在一阶谓词，且该谓词的引用计数需要大于0；
3. 产生递进的两个实体对规则需要在`类型递进表`中存在，该表的位置是`mathnerdevelop/map_files/progressive_table.txt`；
4. 发生一次类型递进，将被递进的实体对的中文类型升级成对应`NOEN`实体对的中文类型，并将该`NOEN`实体对删除，即取消掉这次引入。同时，将被递进实体对的实体对类型变为`UPGRADE`；
5. 一个`NOZH / STD / APPEARED / PARALLEL`实体对最多被递进一次，不能从`UPGRADE` -> `UPGRADE`。

类型递进表`progressive_table.txt`规则如下：

```
...
坐标 坐标|圆心|顶点|交点|焦点
数列 等差数列|等比数列
向量 单位向量|零向量|非零向量|向量
...
```

该表以行为单位，左侧为被递进的中文实体类型，空格分隔中间，右侧以`|`为分隔符表示左侧类型可以递进到的所有中文实体类型。若某个被递进类型不在表中（左侧），则需要新增一条记录。

注1：左侧实体类型和右边的实体类型，从严格意义上讲不能算作知识图谱当中的`子集关系`，尽管`子集关系`是撰写类型递进依据的一个标准。应该说左侧和右侧仅具有一阶谓词逻辑依赖关系。

注2：左侧有几个通用的被递进类型：表达式、方程、等式、不等式、点、变量、值等，会发现他们的记录一般比较长，这通常和类型补全有关。在不能通过正则表达式细化到它的准确的实体类型的前提下，只能补全一个看起来较为相近的实体类型，最不济就是表达式了。但被补全类型的实体也许会在后文有一阶谓词表述，用来修正到真实的实体类型。

什么是所谓的**惰性递进原则**呢，就是假如满足了类型递进原则的1和2，但不满足3，则也不发生类型递进，保留后面被引入的实体。当你想要这二者发生递进，需要你衡量利弊与正确性，然后将其加入到类型递进表当中（或者放弃你的这次想法）。诚然，这带来了一定的工作量，但如果忽视掉3，在遇到嵌套多个谓词逻辑的长难句时，事情会变得难以控制。

#### PART4: "中是英"短距递进预先检测

这一部针对的是嵌套一阶谓词的复杂句式的预先递进处理。

```
例：$P$是圆心为$O$的圆上的一动点
```

里面有两个一阶谓词关系：
1. $P$是...动点
2. 圆心为$O$

但是观察后还有一个**伪**一阶谓词关系：$P$是圆心。按照阅读顺序，当读到"圆心"这个单词时，前面已经构成了一阶谓词逻辑。如果按照谓语动词的下标往两侧分析的话，也会得到这个结果，但它是错的。

为了避免这种情况，经过对大量题目的观察后，**若一个谓语动词左侧紧挨中文实体类型，右侧紧挨英文实体名称，即"中是英"（用"是"代表谓词），一般是一个完整的一阶谓词逻辑结构**。反之，"英是中"则不能保证是一个完整的结构。没有依据，也许这与人的说话习惯有关。

因此在进行`PART5`的一般性质的类型递进之前，需要预先检测这种短距离的特殊的一阶谓词结构，将对应谓词的引用计数减1，并升级被递进实体的类型。

针对没有并列结构、但存在嵌套一阶谓词逻辑的句子，这是一种行之有效的方法。

#### PART5: "由外而内"的类型递进过程

"由外而内"的类型递进，就是当检测到还有引用计数大于0的谓词时，从两侧向中间靠拢检查是否存在满足类型递进关系的两个实体对。至于原因，也只能说是一种观测题目得出的经验之谈。

对于`PART4`中的例子，如果不使用`PART4`中的技术，"由外而内"的方式可以匹配到正确的`<动点, P>`和`<圆心, O>`（但这不能说明`PART4`是可有可无的）。

变换一下这个例子：

例：$P$是$O$为圆心的圆上的一动点

变换了一下内部短距离一阶谓词结构的顺序，`PART4`中的技术就不能生效了。此时"由外而内"的方式可以起到作用。

很显然，"由外而内"的检测方式，是为了**保证远距离的一阶谓词逻辑结构的生效**，需要句子结构不能太过复杂、类型递进表足够精确等多种因素同时作用。

#### PART6: 并列结构的中文类型修复

上面所有的类型递进方式，句式结构可以相对复杂，但如果包含并列成分，结果可能是未知的。如`PART2`中的例子：

```
例：$P$、$M$、$N$分别是线段$AB$、$CD$、$EF$的中点
```

之前提到过，**实体引入**不再使用带数量词的多实体引入（目前这里比较混乱，仍没有统一的方法），也就是这个例子只会引入一个新的中点实体：

```
$P$、$M$、$N$分别是线段$AB$、$CD$、$EF$的中点rs0
```

可以视作

```
(点)oe0(NOZH)、(点)oe1(PARALLEL<oe0>)、(点)oe2(PARALLEL<oe0>)分别是线段(线段)oe3(STD)、(线段)oe4(PARALLEL<oe3>)、(线段)oe5(PARALLEL<oe3>)的中点(中点)rs0(NOEN)
```

`oe0`会被类型升级为中点，引入`rs0`会被取消，`是`的引用计数会被置为0。但实际上，`oe1`和`oe2`也是中点，由于谓词的引用计数不再大于0且没有可用的`NOEN`实体对，`oe1`和`oe2`只能保留被补全的实体类型：`点`。

为了修正这种错误，**并列成分中的非首个成员需要保持和首个成员的中文实体类型一致**，这是规定，也符合自然语言的逻辑。这也就是为什么`oe1`和`oe2`的实体对类型不是`NOZH`而是`PARALLEL<oe0>`的原因，会在这一步通过正则表达式找到从属的首个实体，并修改成对应的中文实体类型。对`oe4`和`oe5`同理。

语言表述的不规范导致并列成分的检测成为了一个难题，以三元并列为例，以下可能都是表示并列的说法：

```
A、B、C分别是...
A,B,C分别是...
A,B和C分别是...
A,B与C分别是...
A和B和C分别是...
A与B与C分别是...
A与B和C分别是...
...
```

一部分原因是标点符号的混用，另一部分原因是中文连词（和、与等）的一词多义问题。我们将连词左右的实体类型视为相同，但可能根本就不是这样：

```
origin sentence: $BC$与$ABC$和$DEF$分别相交于$P$和$Q$
mapped sentence: oe0与oe1和oe2分别相交于oe3和oe4
```

此问题仍有待更好的解决方案。